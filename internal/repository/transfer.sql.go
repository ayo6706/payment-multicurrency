// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transfer.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkTransactionIdempotency = `-- name: CheckTransactionIdempotency :one
SELECT id, amount, currency, type, status, reference_id, fx_rate, created_at 
FROM transactions 
WHERE reference_id = $1
`

type CheckTransactionIdempotencyRow struct {
	ID          pgtype.UUID        `db:"id" json:"id"`
	Amount      int64              `db:"amount" json:"amount"`
	Currency    string             `db:"currency" json:"currency"`
	Type        string             `db:"type" json:"type"`
	Status      string             `db:"status" json:"status"`
	ReferenceID string             `db:"reference_id" json:"reference_id"`
	FxRate      pgtype.Numeric     `db:"fx_rate" json:"fx_rate"`
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

func (q *Queries) CheckTransactionIdempotency(ctx context.Context, referenceID string) (CheckTransactionIdempotencyRow, error) {
	row := q.db.QueryRow(ctx, checkTransactionIdempotency, referenceID)
	var i CheckTransactionIdempotencyRow
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.Currency,
		&i.Type,
		&i.Status,
		&i.ReferenceID,
		&i.FxRate,
		&i.CreatedAt,
	)
	return i, err
}

const createEntry = `-- name: CreateEntry :one
INSERT INTO entries (id, transaction_id, account_id, amount, direction, created_at) 
VALUES ($1, $2, $3, $4, $5, NOW())
RETURNING id
`

type CreateEntryParams struct {
	ID            pgtype.UUID `db:"id" json:"id"`
	TransactionID pgtype.UUID `db:"transaction_id" json:"transaction_id"`
	AccountID     pgtype.UUID `db:"account_id" json:"account_id"`
	Amount        int64       `db:"amount" json:"amount"`
	Direction     string      `db:"direction" json:"direction"`
}

func (q *Queries) CreateEntry(ctx context.Context, arg CreateEntryParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createEntry,
		arg.ID,
		arg.TransactionID,
		arg.AccountID,
		arg.Amount,
		arg.Direction,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (id, amount, currency, type, status, reference_id, fx_rate, metadata, created_at) 
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW())
RETURNING id
`

type CreateTransactionParams struct {
	ID          pgtype.UUID    `db:"id" json:"id"`
	Amount      int64          `db:"amount" json:"amount"`
	Currency    string         `db:"currency" json:"currency"`
	Type        string         `db:"type" json:"type"`
	Status      string         `db:"status" json:"status"`
	ReferenceID string         `db:"reference_id" json:"reference_id"`
	FxRate      pgtype.Numeric `db:"fx_rate" json:"fx_rate"`
	Metadata    []byte         `db:"metadata" json:"metadata"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.ID,
		arg.Amount,
		arg.Currency,
		arg.Type,
		arg.Status,
		arg.ReferenceID,
		arg.FxRate,
		arg.Metadata,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const getAccountBalanceAndCurrency = `-- name: GetAccountBalanceAndCurrency :one
SELECT balance, currency FROM accounts WHERE id = $1
`

type GetAccountBalanceAndCurrencyRow struct {
	Balance  int64  `db:"balance" json:"balance"`
	Currency string `db:"currency" json:"currency"`
}

func (q *Queries) GetAccountBalanceAndCurrency(ctx context.Context, id pgtype.UUID) (GetAccountBalanceAndCurrencyRow, error) {
	row := q.db.QueryRow(ctx, getAccountBalanceAndCurrency, id)
	var i GetAccountBalanceAndCurrencyRow
	err := row.Scan(&i.Balance, &i.Currency)
	return i, err
}

const getAccountCurrency = `-- name: GetAccountCurrency :one
SELECT currency FROM accounts WHERE id = $1
`

func (q *Queries) GetAccountCurrency(ctx context.Context, id pgtype.UUID) (string, error) {
	row := q.db.QueryRow(ctx, getAccountCurrency, id)
	var currency string
	err := row.Scan(&currency)
	return currency, err
}

const getTransaction = `-- name: GetTransaction :one
SELECT id, amount, currency, type, status, reference_id, fx_rate, metadata, created_at
FROM transactions
WHERE id = $1
`

type GetTransactionRow struct {
	ID          pgtype.UUID        `db:"id" json:"id"`
	Amount      int64              `db:"amount" json:"amount"`
	Currency    string             `db:"currency" json:"currency"`
	Type        string             `db:"type" json:"type"`
	Status      string             `db:"status" json:"status"`
	ReferenceID string             `db:"reference_id" json:"reference_id"`
	FxRate      pgtype.Numeric     `db:"fx_rate" json:"fx_rate"`
	Metadata    []byte             `db:"metadata" json:"metadata"`
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

func (q *Queries) GetTransaction(ctx context.Context, id pgtype.UUID) (GetTransactionRow, error) {
	row := q.db.QueryRow(ctx, getTransaction, id)
	var i GetTransactionRow
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.Currency,
		&i.Type,
		&i.Status,
		&i.ReferenceID,
		&i.FxRate,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const getTransactionStatusForUpdate = `-- name: GetTransactionStatusForUpdate :one
SELECT status
FROM transactions
WHERE id = $1
FOR UPDATE
`

func (q *Queries) GetTransactionStatusForUpdate(ctx context.Context, id pgtype.UUID) (string, error) {
	row := q.db.QueryRow(ctx, getTransactionStatusForUpdate, id)
	var status string
	err := row.Scan(&status)
	return status, err
}

const lockAccount = `-- name: LockAccount :one
SELECT id FROM accounts WHERE id = $1 FOR UPDATE
`

func (q *Queries) LockAccount(ctx context.Context, id pgtype.UUID) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, lockAccount, id)
	err := row.Scan(&id)
	return id, err
}

const updateAccountBalance = `-- name: UpdateAccountBalance :execrows
UPDATE accounts
SET balance = balance + $1
WHERE id = $2
`

type UpdateAccountBalanceParams struct {
	Balance int64       `db:"balance" json:"balance"`
	ID      pgtype.UUID `db:"id" json:"id"`
}

func (q *Queries) UpdateAccountBalance(ctx context.Context, arg UpdateAccountBalanceParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateAccountBalance, arg.Balance, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateTransactionFx = `-- name: UpdateTransactionFx :execrows
UPDATE transactions
SET fx_rate = $1,
    metadata = $2
WHERE id = $3
`

type UpdateTransactionFxParams struct {
	FxRate   pgtype.Numeric `db:"fx_rate" json:"fx_rate"`
	Metadata []byte         `db:"metadata" json:"metadata"`
	ID       pgtype.UUID    `db:"id" json:"id"`
}

func (q *Queries) UpdateTransactionFx(ctx context.Context, arg UpdateTransactionFxParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateTransactionFx, arg.FxRate, arg.Metadata, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateTransactionStatus = `-- name: UpdateTransactionStatus :execrows
UPDATE transactions
SET status = $1
WHERE id = $2
`

type UpdateTransactionStatusParams struct {
	Status string      `db:"status" json:"status"`
	ID     pgtype.UUID `db:"id" json:"id"`
}

func (q *Queries) UpdateTransactionStatus(ctx context.Context, arg UpdateTransactionStatusParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateTransactionStatus, arg.Status, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
