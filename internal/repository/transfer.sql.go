// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transfer.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkTransactionIdempotency = `-- name: CheckTransactionIdempotency :one
SELECT id, amount, currency, type, status, reference_id, fx_rate, created_at 
FROM transactions 
WHERE reference_id = $1
`

type CheckTransactionIdempotencyRow struct {
	ID          pgtype.UUID      `db:"id" json:"id"`
	Amount      int64            `db:"amount" json:"amount"`
	Currency    string           `db:"currency" json:"currency"`
	Type        string           `db:"type" json:"type"`
	Status      string           `db:"status" json:"status"`
	ReferenceID string           `db:"reference_id" json:"reference_id"`
	FxRate      pgtype.Numeric   `db:"fx_rate" json:"fx_rate"`
	CreatedAt   pgtype.Timestamp `db:"created_at" json:"created_at"`
}

func (q *Queries) CheckTransactionIdempotency(ctx context.Context, referenceID string) (CheckTransactionIdempotencyRow, error) {
	row := q.db.QueryRow(ctx, checkTransactionIdempotency, referenceID)
	var i CheckTransactionIdempotencyRow
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.Currency,
		&i.Type,
		&i.Status,
		&i.ReferenceID,
		&i.FxRate,
		&i.CreatedAt,
	)
	return i, err
}

const createEntry = `-- name: CreateEntry :one
INSERT INTO entries (id, transaction_id, account_id, amount, direction, created_at) 
VALUES ($1, $2, $3, $4, $5, NOW())
RETURNING id
`

type CreateEntryParams struct {
	ID            pgtype.UUID `db:"id" json:"id"`
	TransactionID pgtype.UUID `db:"transaction_id" json:"transaction_id"`
	AccountID     pgtype.UUID `db:"account_id" json:"account_id"`
	Amount        int64       `db:"amount" json:"amount"`
	Direction     string      `db:"direction" json:"direction"`
}

func (q *Queries) CreateEntry(ctx context.Context, arg CreateEntryParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createEntry,
		arg.ID,
		arg.TransactionID,
		arg.AccountID,
		arg.Amount,
		arg.Direction,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (id, amount, currency, type, status, reference_id, fx_rate, metadata, created_at) 
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW())
RETURNING id
`

type CreateTransactionParams struct {
	ID          pgtype.UUID    `db:"id" json:"id"`
	Amount      int64          `db:"amount" json:"amount"`
	Currency    string         `db:"currency" json:"currency"`
	Type        string         `db:"type" json:"type"`
	Status      string         `db:"status" json:"status"`
	ReferenceID string         `db:"reference_id" json:"reference_id"`
	FxRate      pgtype.Numeric `db:"fx_rate" json:"fx_rate"`
	Metadata    []byte         `db:"metadata" json:"metadata"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.ID,
		arg.Amount,
		arg.Currency,
		arg.Type,
		arg.Status,
		arg.ReferenceID,
		arg.FxRate,
		arg.Metadata,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const getAccountBalanceAndCurrency = `-- name: GetAccountBalanceAndCurrency :one
SELECT balance, currency FROM accounts WHERE id = $1
`

type GetAccountBalanceAndCurrencyRow struct {
	Balance  int64  `db:"balance" json:"balance"`
	Currency string `db:"currency" json:"currency"`
}

func (q *Queries) GetAccountBalanceAndCurrency(ctx context.Context, id pgtype.UUID) (GetAccountBalanceAndCurrencyRow, error) {
	row := q.db.QueryRow(ctx, getAccountBalanceAndCurrency, id)
	var i GetAccountBalanceAndCurrencyRow
	err := row.Scan(&i.Balance, &i.Currency)
	return i, err
}

const getAccountCurrency = `-- name: GetAccountCurrency :one
SELECT currency FROM accounts WHERE id = $1
`

func (q *Queries) GetAccountCurrency(ctx context.Context, id pgtype.UUID) (string, error) {
	row := q.db.QueryRow(ctx, getAccountCurrency, id)
	var currency string
	err := row.Scan(&currency)
	return currency, err
}

const lockAccount = `-- name: LockAccount :one
SELECT id FROM accounts WHERE id = $1 FOR UPDATE
`

func (q *Queries) LockAccount(ctx context.Context, id pgtype.UUID) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, lockAccount, id)
	err := row.Scan(&id)
	return id, err
}

const updateAccountBalance = `-- name: UpdateAccountBalance :exec
UPDATE accounts 
SET balance = balance + $1 
WHERE id = $2
`

type UpdateAccountBalanceParams struct {
	Balance int64       `db:"balance" json:"balance"`
	ID      pgtype.UUID `db:"id" json:"id"`
}

func (q *Queries) UpdateAccountBalance(ctx context.Context, arg UpdateAccountBalanceParams) error {
	_, err := q.db.Exec(ctx, updateAccountBalance, arg.Balance, arg.ID)
	return err
}
