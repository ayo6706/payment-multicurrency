// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payout.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getPayout = `-- name: GetPayout :one
SELECT id, transaction_id, account_id, amount_micros, currency, status, gateway_ref, created_at, updated_at FROM payouts WHERE id = $1
`

func (q *Queries) GetPayout(ctx context.Context, id pgtype.UUID) (Payout, error) {
	row := q.db.QueryRow(ctx, getPayout, id)
	var i Payout
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.AccountID,
		&i.AmountMicros,
		&i.Currency,
		&i.Status,
		&i.GatewayRef,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPayoutByTransactionID = `-- name: GetPayoutByTransactionID :one
SELECT id, transaction_id, account_id, amount_micros, currency, status, gateway_ref, created_at, updated_at FROM payouts WHERE transaction_id = $1
`

func (q *Queries) GetPayoutByTransactionID(ctx context.Context, transactionID pgtype.UUID) (Payout, error) {
	row := q.db.QueryRow(ctx, getPayoutByTransactionID, transactionID)
	var i Payout
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.AccountID,
		&i.AmountMicros,
		&i.Currency,
		&i.Status,
		&i.GatewayRef,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPendingPayouts = `-- name: GetPendingPayouts :many
SELECT id, transaction_id, account_id, amount_micros, currency, status, gateway_ref, created_at, updated_at FROM payouts 
WHERE status = 'PENDING' 
ORDER BY created_at ASC
FOR UPDATE SKIP LOCKED 
LIMIT $1
`

func (q *Queries) GetPendingPayouts(ctx context.Context, limit int32) ([]Payout, error) {
	rows, err := q.db.Query(ctx, getPendingPayouts, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payout
	for rows.Next() {
		var i Payout
		if err := rows.Scan(
			&i.ID,
			&i.TransactionID,
			&i.AccountID,
			&i.AmountMicros,
			&i.Currency,
			&i.Status,
			&i.GatewayRef,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertPayout = `-- name: InsertPayout :one
INSERT INTO payouts (id, transaction_id, account_id, amount_micros, currency, status, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
RETURNING id, transaction_id, account_id, amount_micros, currency, status, gateway_ref, created_at, updated_at
`

type InsertPayoutParams struct {
	ID            pgtype.UUID `db:"id" json:"id"`
	TransactionID pgtype.UUID `db:"transaction_id" json:"transaction_id"`
	AccountID     pgtype.UUID `db:"account_id" json:"account_id"`
	AmountMicros  int64       `db:"amount_micros" json:"amount_micros"`
	Currency      string      `db:"currency" json:"currency"`
	Status        string      `db:"status" json:"status"`
}

func (q *Queries) InsertPayout(ctx context.Context, arg InsertPayoutParams) (Payout, error) {
	row := q.db.QueryRow(ctx, insertPayout,
		arg.ID,
		arg.TransactionID,
		arg.AccountID,
		arg.AmountMicros,
		arg.Currency,
		arg.Status,
	)
	var i Payout
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.AccountID,
		&i.AmountMicros,
		&i.Currency,
		&i.Status,
		&i.GatewayRef,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePayoutStatus = `-- name: UpdatePayoutStatus :exec
UPDATE payouts
SET status = $1, gateway_ref = $2, updated_at = NOW()
WHERE id = $3
`

type UpdatePayoutStatusParams struct {
	Status     string      `db:"status" json:"status"`
	GatewayRef *string     `db:"gateway_ref" json:"gateway_ref"`
	ID         pgtype.UUID `db:"id" json:"id"`
}

func (q *Queries) UpdatePayoutStatus(ctx context.Context, arg UpdatePayoutStatusParams) error {
	_, err := q.db.Exec(ctx, updatePayoutStatus, arg.Status, arg.GatewayRef, arg.ID)
	return err
}
