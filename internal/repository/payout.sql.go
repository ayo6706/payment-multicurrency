// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payout.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPayoutsByStatus = `-- name: CountPayoutsByStatus :one
SELECT COUNT(*)::bigint FROM payouts
WHERE status = $1
`

func (q *Queries) CountPayoutsByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRow(ctx, countPayoutsByStatus, status)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const getPayout = `-- name: GetPayout :one
SELECT id, transaction_id, account_id, amount_micros, currency, status, gateway_ref, created_at, updated_at FROM payouts WHERE id = $1
`

func (q *Queries) GetPayout(ctx context.Context, id pgtype.UUID) (Payout, error) {
	row := q.db.QueryRow(ctx, getPayout, id)
	var i Payout
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.AccountID,
		&i.AmountMicros,
		&i.Currency,
		&i.Status,
		&i.GatewayRef,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPayoutByTransactionID = `-- name: GetPayoutByTransactionID :one
SELECT id, transaction_id, account_id, amount_micros, currency, status, gateway_ref, created_at, updated_at FROM payouts WHERE transaction_id = $1
`

func (q *Queries) GetPayoutByTransactionID(ctx context.Context, transactionID pgtype.UUID) (Payout, error) {
	row := q.db.QueryRow(ctx, getPayoutByTransactionID, transactionID)
	var i Payout
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.AccountID,
		&i.AmountMicros,
		&i.Currency,
		&i.Status,
		&i.GatewayRef,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPayoutForUpdate = `-- name: GetPayoutForUpdate :one
SELECT id, transaction_id, account_id, amount_micros, currency, status, gateway_ref, created_at, updated_at FROM payouts WHERE id = $1 FOR UPDATE
`

func (q *Queries) GetPayoutForUpdate(ctx context.Context, id pgtype.UUID) (Payout, error) {
	row := q.db.QueryRow(ctx, getPayoutForUpdate, id)
	var i Payout
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.AccountID,
		&i.AmountMicros,
		&i.Currency,
		&i.Status,
		&i.GatewayRef,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPayoutsByStatus = `-- name: GetPayoutsByStatus :many
SELECT id, transaction_id, account_id, amount_micros, currency, status, gateway_ref, created_at, updated_at FROM payouts
WHERE status = $1
ORDER BY updated_at DESC, created_at DESC
LIMIT $2 OFFSET $3
`

type GetPayoutsByStatusParams struct {
	Status string `db:"status" json:"status"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

func (q *Queries) GetPayoutsByStatus(ctx context.Context, arg GetPayoutsByStatusParams) ([]Payout, error) {
	rows, err := q.db.Query(ctx, getPayoutsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payout
	for rows.Next() {
		var i Payout
		if err := rows.Scan(
			&i.ID,
			&i.TransactionID,
			&i.AccountID,
			&i.AmountMicros,
			&i.Currency,
			&i.Status,
			&i.GatewayRef,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingPayouts = `-- name: GetPendingPayouts :many
SELECT id, transaction_id, account_id, amount_micros, currency, status, gateway_ref, created_at, updated_at FROM payouts 
WHERE status = 'PENDING' 
ORDER BY created_at ASC
FOR UPDATE SKIP LOCKED 
LIMIT $1
`

func (q *Queries) GetPendingPayouts(ctx context.Context, limit int32) ([]Payout, error) {
	rows, err := q.db.Query(ctx, getPendingPayouts, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payout
	for rows.Next() {
		var i Payout
		if err := rows.Scan(
			&i.ID,
			&i.TransactionID,
			&i.AccountID,
			&i.AmountMicros,
			&i.Currency,
			&i.Status,
			&i.GatewayRef,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStaleProcessingPayouts = `-- name: GetStaleProcessingPayouts :many
SELECT id, transaction_id, account_id, amount_micros, currency, status, gateway_ref, created_at, updated_at FROM payouts
WHERE status = 'PROCESSING' AND updated_at < $1
ORDER BY updated_at ASC
FOR UPDATE SKIP LOCKED
LIMIT $2
`

type GetStaleProcessingPayoutsParams struct {
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	Limit     int32              `db:"limit" json:"limit"`
}

func (q *Queries) GetStaleProcessingPayouts(ctx context.Context, arg GetStaleProcessingPayoutsParams) ([]Payout, error) {
	rows, err := q.db.Query(ctx, getStaleProcessingPayouts, arg.UpdatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payout
	for rows.Next() {
		var i Payout
		if err := rows.Scan(
			&i.ID,
			&i.TransactionID,
			&i.AccountID,
			&i.AmountMicros,
			&i.Currency,
			&i.Status,
			&i.GatewayRef,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertPayout = `-- name: InsertPayout :one
INSERT INTO payouts (id, transaction_id, account_id, amount_micros, currency, status, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
RETURNING id, transaction_id, account_id, amount_micros, currency, status, gateway_ref, created_at, updated_at
`

type InsertPayoutParams struct {
	ID            pgtype.UUID `db:"id" json:"id"`
	TransactionID pgtype.UUID `db:"transaction_id" json:"transaction_id"`
	AccountID     pgtype.UUID `db:"account_id" json:"account_id"`
	AmountMicros  int64       `db:"amount_micros" json:"amount_micros"`
	Currency      string      `db:"currency" json:"currency"`
	Status        string      `db:"status" json:"status"`
}

func (q *Queries) InsertPayout(ctx context.Context, arg InsertPayoutParams) (Payout, error) {
	row := q.db.QueryRow(ctx, insertPayout,
		arg.ID,
		arg.TransactionID,
		arg.AccountID,
		arg.AmountMicros,
		arg.Currency,
		arg.Status,
	)
	var i Payout
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.AccountID,
		&i.AmountMicros,
		&i.Currency,
		&i.Status,
		&i.GatewayRef,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePayoutStatus = `-- name: UpdatePayoutStatus :execrows
UPDATE payouts
SET status = $1, gateway_ref = $2, updated_at = NOW()
WHERE id = $3
`

type UpdatePayoutStatusParams struct {
	Status     string      `db:"status" json:"status"`
	GatewayRef *string     `db:"gateway_ref" json:"gateway_ref"`
	ID         pgtype.UUID `db:"id" json:"id"`
}

func (q *Queries) UpdatePayoutStatus(ctx context.Context, arg UpdatePayoutStatusParams) (int64, error) {
	result, err := q.db.Exec(ctx, updatePayoutStatus, arg.Status, arg.GatewayRef, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
