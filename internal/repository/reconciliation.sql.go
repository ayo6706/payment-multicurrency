// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reconciliation.sql

package repository

import (
	"context"
)

const getLedgerCurrencyImbalances = `-- name: GetLedgerCurrencyImbalances :many
SELECT
  a.currency,
  COALESCE(SUM(
    CASE
      WHEN e.direction = 'credit' THEN e.amount
      WHEN e.direction = 'debit' THEN -e.amount
      ELSE 0
    END
  ), 0)::bigint AS net_amount
FROM entries e
INNER JOIN accounts a ON a.id = e.account_id
GROUP BY a.currency
HAVING COALESCE(SUM(
  CASE
    WHEN e.direction = 'credit' THEN e.amount
    WHEN e.direction = 'debit' THEN -e.amount
    ELSE 0
  END
), 0) <> 0
`

type GetLedgerCurrencyImbalancesRow struct {
	Currency  string `db:"currency" json:"currency"`
	NetAmount int64  `db:"net_amount" json:"net_amount"`
}

func (q *Queries) GetLedgerCurrencyImbalances(ctx context.Context) ([]GetLedgerCurrencyImbalancesRow, error) {
	rows, err := q.db.Query(ctx, getLedgerCurrencyImbalances)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLedgerCurrencyImbalancesRow
	for rows.Next() {
		var i GetLedgerCurrencyImbalancesRow
		if err := rows.Scan(&i.Currency, &i.NetAmount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLedgerNet = `-- name: GetLedgerNet :one
SELECT COALESCE(SUM(
  CASE
    WHEN direction = 'credit' THEN amount
    WHEN direction = 'debit' THEN -amount
    ELSE 0
  END
), 0)::bigint AS net_amount
FROM entries
`

func (q *Queries) GetLedgerNet(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getLedgerNet)
	var net_amount int64
	err := row.Scan(&net_amount)
	return net_amount, err
}
